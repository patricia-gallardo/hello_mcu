/**
 * \file
 * \brief Interface to the speaker on the PRG_G board.
 * \author Erich Styger, erich.styger@hslu.ch
 *
 * This module implements to functions to use the speaker.
 */

#include "Platform.h"
#include "Speaker.h"
#include "DAC.h"
#include "McuWait.h"

#define SINE_TABLE_DIVISOR  (16)
  /*!< Reduction factor for sine table, to simplify things and not add too much waiting overhead */

/* http://www.daycounter.com/Calculators/Sine-Generator-Calculator.phtml
 * max 3300, 256 values */
static const uint16_t sinTable[] = {
  0x672,0x69a,0x6c3,0x6eb,0x714,0x73c,0x764,0x78c,
  0x7b4,0x7dc,0x803,0x82a,0x851,0x878,0x89e,0x8c4,
  0x8e9,0x90f,0x933,0x958,0x97c,0x99f,0x9c2,0x9e5,
  0xa07,0xa28,0xa49,0xa69,0xa89,0xaa8,0xac6,0xae4,
  0xb01,0xb1d,0xb39,0xb53,0xb6d,0xb87,0xb9f,0xbb7,
  0xbce,0xbe4,0xbf9,0xc0e,0xc21,0xc34,0xc46,0xc56,
  0xc66,0xc75,0xc84,0xc91,0xc9d,0xca8,0xcb3,0xcbc,
  0xcc4,0xccc,0xcd2,0xcd8,0xcdc,0xce0,0xce2,0xce4,
  0xce4,0xce4,0xce2,0xce0,0xcdc,0xcd8,0xcd2,0xccc,
  0xcc4,0xcbc,0xcb3,0xca8,0xc9d,0xc91,0xc84,0xc75,
  0xc66,0xc56,0xc46,0xc34,0xc21,0xc0e,0xbf9,0xbe4,
  0xbce,0xbb7,0xb9f,0xb87,0xb6d,0xb53,0xb39,0xb1d,
  0xb01,0xae4,0xac6,0xaa8,0xa89,0xa69,0xa49,0xa28,
  0xa07,0x9e5,0x9c2,0x99f,0x97c,0x958,0x933,0x90f,
  0x8e9,0x8c4,0x89e,0x878,0x851,0x82a,0x803,0x7dc,
  0x7b4,0x78c,0x764,0x73c,0x714,0x6eb,0x6c3,0x69a,
  0x672,0x64a,0x621,0x5f9,0x5d0,0x5a8,0x580,0x558,
  0x530,0x508,0x4e1,0x4ba,0x493,0x46c,0x446,0x420,
  0x3fb,0x3d5,0x3b1,0x38c,0x368,0x345,0x322,0x2ff,
  0x2dd,0x2bc,0x29b,0x27b,0x25b,0x23c,0x21e,0x200,
  0x1e3,0x1c7,0x1ab,0x191,0x177,0x15d,0x145,0x12d,
  0x116,0x100,0xeb,0xd6,0xc3,0xb0,0x9e,0x8e,
  0x7e,0x6f,0x60,0x53,0x47,0x3c,0x31,0x28,
  0x20,0x18,0x12,0xc,0x8,0x4,0x2,0x0,
  0x0,0x0,0x2,0x4,0x8,0xc,0x12,0x18,
  0x20,0x28,0x31,0x3c,0x47,0x53,0x60,0x6f,
  0x7e,0x8e,0x9e,0xb0,0xc3,0xd6,0xeb,0x100,
  0x116,0x12d,0x145,0x15d,0x177,0x191,0x1ab,0x1c7,
  0x1e3,0x200,0x21e,0x23c,0x25b,0x27b,0x29b,0x2bc,
  0x2dd,0x2ff,0x322,0x345,0x368,0x38c,0x3b1,0x3d5,
  0x3fb,0x420,0x446,0x46c,0x493,0x4ba,0x4e1,0x508,
  0x530,0x558,0x580,0x5a8,0x5d0,0x5f9,0x621,0x64a
};


void SPEAKER_Play(uint32_t freqHz, uint32_t timeMs) {
  uint32_t iterations, usDelay, nofValues;
  unsigned int i;

  /* speaker frequency range: 400 Hz - 20 kHz */
  nofValues = sizeof(sinTable)/sizeof(sinTable[0])/SINE_TABLE_DIVISOR; /* only using a portion of the values in th sine table */
  iterations = (timeMs*freqHz)/1000;
  usDelay = ((1000*1000)/freqHz)/nofValues; /* delay after each value */
  DAC_Start();
  while (iterations>0) {
    for(i=0;i<sizeof(sinTable)/sizeof(sinTable[0]);i+=SINE_TABLE_DIVISOR) { /* go through one sine wave */
      DAC_SetMilliVolt(sinTable[i]);
      McuWait_Waitus(usDelay);
    }
    iterations--;
  }
  DAC_SetMilliVolt(0);
  DAC_Stop();
}

/*! struct to hold data for the speaker waveform */
struct {
  bool isPlaying;
  uint32_t frequencyHz;
  uint32_t delayUs;
  uint32_t sineIdx;
} SPEAKER_IsrData;

void SPEAKER_OnInterrupt(void) {
	if (SPEAKER_IsrData.isPlaying) {
		DAC_SetMilliVolt(sinTable[SPEAKER_IsrData.sineIdx]);
	      McuWait_Waitus(50);
		SPEAKER_IsrData.sineIdx += SINE_TABLE_DIVISOR;
		if (SPEAKER_IsrData.sineIdx>=sizeof(sinTable)/sizeof(sinTable[0])) {
			SPEAKER_IsrData.sineIdx = 0; /* restart */
		}
	}
}

void SPEAKER_StartPlaying(uint32_t freqHz) {
	uint32_t nofValues;

	SPEAKER_IsrData.sineIdx = 0;
	SPEAKER_IsrData.frequencyHz = freqHz;
	nofValues = sizeof(sinTable)/sizeof(sinTable[0])/SINE_TABLE_DIVISOR; /* only using a portion of the values in the sine table */
	SPEAKER_IsrData.delayUs = ((1000*1000)/freqHz)/nofValues; /* delay after each value */
	SPEAKER_IsrData.isPlaying = TRUE;
	DAC_Start();
}

void SPEAKER_StopPlaying(void) {
	SPEAKER_IsrData.isPlaying = FALSE;
	DAC_SetMilliVolt(0);
	DAC_Stop();
}


void SPEAKER_Init(void) {
	SPEAKER_IsrData.isPlaying = FALSE;
}
